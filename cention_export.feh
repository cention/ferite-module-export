uses "/cention/etc/webframework-config.feh";
uses "webframework/webframework";
uses "workflow";
uses "MailUtilities";
uses "cmail";

/*
 * TODO:
 *   Generate SQL to fetch the data from the database - mostly done just need to implement email and word list checks
 *   Implement disk space unique row checking - this will probably have to be some sort of disk-base btree structure 
 */

global {
	boolean logToConsole = true;
	boolean logToFile = true;
	string logFile = '/cention/logs/Exports.log';
	object logFileObject;
	object logClosure;
}

/**
 * @function log
 * @declaration function log( string text )
 * @brief Logs a string of text either to the console or to a file
 * @param string text the text to log
 */
function log( object export, string text ) {
	text = '[' + formatDateTime(Date.GMTnow()) + '] {' + export.name + '} ' + text;

	if( logToConsole )
		Console.println( text );
	
	if( logToFile ) {
		if( not logFileObject ) {
			if( not Posix.stat(logFile) ) {
				Posix.umask(0);
				logFileObject = File.create( logFile, 0644);
				logFileObject = File.open( logFile, FileSystem.O_RDWR );
			} else {
				logFileObject = File.open( logFile, FileSystem.O_RDWR );
			}
			if( not logFileObject ) {
				raise new Error("Unable to open log file $logFile. Please check permissions");
			} else {
				logFileObject.seek( logFileObject.length(), Stream.SEEK_SET );
				logFileObject.println("---------------------------------------");
			}
		}
		logFileObject.println( text );
	}
	
	if( logClosure ) {
		logClosure.invoke(text);
	}
}

namespace Exports {
	
	string exportPath = '';

	class ExportResult {
		number errand_id;
		string from_address;
		string to_address;
		string subject;
		string question;
		string answer;

		string original_subject;
		string original_question;
		string original_answer;

		string timestamp_arrived;
		string timestamp_opened;
		string timestamp_answered;
		string timestamp_closed;
		number agent_id;
		string agent_name;
		number area_id;
		string area_name;
		number client_id;
		string priority;
		string tag_names;

		number _internal_timestamp_arrived;
		number _internal_timestamp_opened;
		number _internal_timestamp_answered;
		number _internal_timestamp_closed;

		string _internal_from_address;
		string _internal_errand_text;
		
		function toArray( object format ) {
			array values = [];

			if( format.errandId ) values['errand_id'] = .errand_id;
			if( format.fromAddress ) values['from_address'] = .from_address;
			if( format.toAddress ) values['to_address'] = .to_address;
			if( format.subject ) values['subject'] = (.subject ? .subject : .original_subject);
			if( format.question ) values['question'] = (.question ? .question : .original_question);
			if( format.answer ) values['answer'] = (.answer ? .answer : .original_answer);
			if( format.arrived ) values['timestamp_arrived'] = (._internal_timestamp_arrived ? formatDateTime(._internal_timestamp_arrived) : .timestamp_arrived);
			if( format.opened ) values['timestamp_opened'] = (._internal_timestamp_opened ? formatDateTime(._internal_timestamp_opened) : .timestamp_opened);
			if( format.answered ) values['timestamp_answered'] = (._internal_timestamp_answered ? formatDateTime(._internal_timestamp_answered) : .timestamp_answered);
			if( format.closed ) values['timestamp_closed'] = (._internal_timestamp_closed ? formatDateTime(._internal_timestamp_closed) : .timestamp_closed);
			if( format.agentid ) values['agent_id'] = .agent_id;
			if( format.agentname ) values['agent_name'] = .agent_name;
			if( format.areaid ) values['area_id'] = .area_id;
			if( format.areaname ) values['area_name'] = .area_name;
			if( format.clientid ) values['client_id'] = .client_id;
			if( format.priority ) values['priority'] = .priority;
			if( format.tags ) values['tag_names'] = .tag_names;

			return values;
		}
		function toJSONForFormat( object format ) {
			array objectValues = [];
			array values = .toArray(format);
			values.eachWithIndex() using ( _value, index ) {
				string key = JSON.escape(values.getName(index));
				string value = JSON.valueToJSON(_value);
				objectValues[] = "\"$key\":$value";
			};
			return "{" + objectValues.join(',') + "}";
		}
		function toOrder( object format ) {
			array order = [];
			array values = .toArray(format);
			values.eachWithIndex() using ( _value, index ) {
				order[] = values.getName(index);
			};
			return order;
		}
	}

	abstract class DataWriter {
		static function createForExport( object export ) {
			switch( export.type ) {
				case Workflow.Export.TYPE_EXCEL:
					return new Exports.ExcelDataWriter(export);
				case Workflow.Export.TYPE_CSV:
					return new Exports.CSVDataWriter(export);
				case Workflow.Export.TYPE_XML:
					return new Exports.XMLDataWriter(export);
				case Workflow.Export.TYPE_JSON:
					return new Exports.JSONDataWriter(export);
			}
			return null;
		}
		
		object  export;
		object  outputStream;
		number  recordedCount;
		number  duplicateCount;
		string  tag;

		boolean useMemoryHashCache = true;
		array   memoryHashCache;
		number  memoryHashCacheSwitchLimit = 256000;
		
		constructor( object export ) {
			.export = export;
		}
		function formatDate( number date ) {
			number localDate = date + (Config.TimeZoneOffset * 60);
			return Date.localDate(localDate).format('%Y%m%d');
		}
		function setupPathForExport {
			string path = Exports.exportPath + Regexp.replaceAll(' ', .export.name, '-');
			Directory.build(path);
			return path;
		}
		function setTag( string tag ) {
			.tag = tag;
		}
		
		string stub;
		function filenameStub {
			if( not .stub ) {
				.stub = .setupPathForExport() + "/${Regexp.replaceAll(' ', .export.name, '-')}_${.formatDate(.export.start)}_to_${.formatDate(.export.finish)}_${.tag}";
			}
			return .stub;
		}
		function start {
			string path = .filenameStub() + ".intermediate.json";

			File.remove(path);
			.outputStream = File.create( path, 0644);
			.outputStream = null;

			.recordedCount = 0;
			.duplicateCount = 0;
			
			log( .export, "Starting export writing intermediate data to $path");
		}
		function hasSeenHash( string _hash ) {
			string hash = ":$_hash;";
			if( .useMemoryHashCache ) {
				if( .memoryHashCache.keyExists(hash) ) {
					return true;
				}
				.memoryHashCache[hash] = true;
				if( .memoryHashCache.size() > .memoryHashCacheSwitchLimit ) {
					raise new Error("Hard memory hash limit hit - implement file based lookup of uniqueness");
				}
				return false;
			} else {
				raise new Error("Implement file based lookup of uniqueness");
			}
		}
		function record( array list ) {
			string path = .filenameStub() + ".intermediate.json";
			boolean checkingErrandContents = (.export.getPositiveSearchTerms() or .export.getNegativeSearchTerms() ? true : false);
			boolean checkingFromAddress = (.export.getPositiveEmailLists() or .export.getNegativeEmailLists() ? true : false);

			array positiveSearchTerms = .export.getPositiveSearchTerms();
			array negativeSearchTerms = .export.getNegativeSearchTerms();
			array positiveEmailLists = .export.getPositiveEmailLists();
			array negativeEmailLists = .export.getNegativeEmailLists();

			.outputStream = File.open( path, FileSystem.O_RDWR );
			.outputStream.seek( .outputStream.length(), Stream.SEEK_SET );
			list.each() using ( row ) {
				boolean shouldRecord = true;
				
				if( checkingErrandContents ) {
					shouldRecord = shouldRecord and positiveSearchTerms.each() using ( term ) {
						return (row._internal_errand_text.index(term) >= 0);
					};
					shouldRecord = shouldRecord and negativeEmailLists.each() using ( term ) {
						return (row._internal_errand_text.index(term) == -1);
					};
				}

				if( checkingFromAddress ) {
					shouldRecord = shouldRecord and positiveEmailLists.each() using ( email ) {
						string address = (row.from_address ? row.from_address : row._internal_from_address);
						return (address.index(email) >= 0);
					};
					shouldRecord = shouldRecord and negativeEmailLists.each() using ( email ) {
						string address = (row.from_address ? row.from_address : row._internal_from_address);
						return (address.index(email) == -1);
					};
				}

				if( shouldRecord ) {
					.record(row);
				} else {
					.duplicateCount++;
				}
			};
			.outputStream.flush();
			.outputStream.close();
			.outputStream = null;
			return (list.size() >  0);
		}
		function record( object row ) {
			string json = row.toJSONForFormat(.export.exportFormat);
			string md5 = String.base64encode(MHash.hashString(json, MHash.SHA256));
		
			if( not .hasSeenHash(md5) ) {
				.outputStream.writeln(json);
				.recordedCount++;
				if( (.recordedCount % 1000) == 0 ) {
					log( .export, "Recorded a total of ${.recordedCount} rows.");
				}
			} else {
				.duplicateCount++;
				if( (.duplicateCount % 1000) == 0 ) {
					log( .export, "Ignored a total of ${.duplicateCount} rows.");
				}
			}
		}
		function iterateIntermediateFile( object generated_export ) {
			return .iterateIntermediateFile( generated_export, true, null ) using recipient();
		}
		function iterateIntermediateFile( object generated_export, boolean complex, object continuance ) {
			string path = .filenameStub() + ".intermediate.json";
			object stream = (continuance ? continuance : File.open(path));
			object handler = new Exports.ExportResult();
			number progress = 0;
			
			while( not stream.eos() ) {
				string line = stream.readln().trim(" \r\n");
				number real_progress = 0;
				
				progress++;
				real_progress = ((progress / (.recordedCount + 0.0)) * 50).round() + 50;
				.export.updateProgress( generated_export, real_progress );
				
				if( complex ) {
					if( line ) {
						handler = JSON.parse(line, handler);
						if( deliver(handler) ) {
							break;
						}
					}
				} else {
					if( deliver(line) ) {
						break;
					}
				}
			}
			
			return stream;
		}
		function finishFiles {
			return  [ "- NO FILE TO FINISH -" ];
		}
		function finish {
			if( .outputStream ) {
				.outputStream.flush();
				.outputStream.close();
				.outputStream = null;
			}
		}
	}
	
	class ExcelDataWriter extends DataWriter { 
		number tippingPoint = 20000;

		function finishFiles {
			number totalLeft = .recordedCount;
			
			if( totalLeft < .tippingPoint ) {
				return [ .filenameStub() + ".xls" ];
			} else {
				array list = [];
				while( totalLeft >= .tippingPoint or totalLeft > 0 ) {
					list[] = .filenameStub() + '.part-' + (list.size() + 1) + '.xls';
					totalLeft -= .tippingPoint;
				}
				return list;
			}
		}
		
		function finish( object generated_export ) {
			object output = null;
			array paths = .finishFiles();
			boolean writtenHeader = false;
			array header = [];
			object stream = null;
			
			super.finish();

			paths.each() using ( path ) {
				number count = 0;
				
				File.remove(path);
				output = File.create( path, 0644);
				output = File.open( path, FileSystem.O_RDWR );
				output.writeln("<html>");
				output.writeln("<body>");
				output.writeln("<table>");

				stream = .iterateIntermediateFile( generated_export, true, stream ) using ( row ) {
					array values = row.toArray(.export.exportFormat);
					array xml_tags = [];

					values.eachWithIndex() using ( value, index ) {
						if( not writtenHeader ) {
							header[] = values.getName(index);
						}
						if( value isa string ) {
							xml_tags[] = "\t\t<td>${EscapeHTML(value)}</td>";
						} else {
							xml_tags[] = "\t\t<td>$value</td>";
						}
					};
				
					if( not writtenHeader ) {
						output.writeln("\t<tr>");
						output.writeln(header.join("\n") using ( key ) {
							return "<td>$key</td>";
						});
						output.writeln("\t</tr>");
						writtenHeader = true;
					}

					output.writeln("\t<tr>");
					output.writeln(xml_tags.join("\n"));
					output.writeln("\t</tr>");
					
					count++;
					if( count >= .tippingPoint ) {
						count = 0;
						return true;
					}
				};

				output.writeln("</table>");
				output.writeln("</body>");
				output.writeln("</html>");
				output.flush();
				output.close();
			};
		}
	}
	class CSVDataWriter extends DataWriter { 
		function finishFiles
			return [ .filenameStub() + ".csv" ];
		function finish( object generated_export ) {
			object output = null;
			string path = .filenameStub() + '.csv';
			
			super.finish();
			
			File.remove(path);
			output = File.create( path, 0644);
			output = File.open( path, FileSystem.O_RDWR );

			.iterateIntermediateFile(generated_export) using ( row ) {
				output.writeln(row.toArray(.export.exportFormat).join(',') using ( value ){
					if( value isa string ) {
						string real_value = value;
						real_value = Regexp.replaceAll("\n", real_value, "\\n");
						real_value = Regexp.replaceAll("\r", real_value, "\\r");
						real_value = Regexp.replaceAll("\"", real_value, "\\\"");
						return "\"$real_value\"";
					} else {
						return "$value";
					}
				});
			};

			output.flush();
			output.close();
		}
	}
	class XMLDataWriter extends DataWriter { 
		function finishFiles
			return [ .filenameStub() + ".xml" ];
		function finish( object generated_export ) {
			object output = null;
			string path = .filenameStub() + '.xml';

			super.finish();

			File.remove(path);
			output = File.create( path, 0644);
			output = File.open( path, FileSystem.O_RDWR );
			output.writeln("<?xml version=\"1.0\" ?>");
			output.writeln("<export>");

			.iterateIntermediateFile(generated_export) using ( row ) {
				array values = row.toArray(.export.exportFormat);
				array xml_tags = [];
				
				values.map() using ( key, value ) {
					if( value isa string ) {
						xml_tags[] = "\t\t<$key>${EscapeHTML(value)}</$key>";
					} else {
						xml_tags[] = "\t\t<$key>$value</$key>";
					}
				};
				output.writeln("\t<record>");
				output.writeln(xml_tags.join("\n"));
				output.writeln("\t</record>");
			};

			output.writeln("</export>");
			output.flush();
			output.close();
		}
	}
	class JSONDataWriter extends DataWriter { 
		function finishFiles
			return  [ .filenameStub() + ".json" ];
		function finish( object generated_export ) {
			object output = null;
			string path = .filenameStub() + '.json';
			string pendingComma = '';

			super.finish();

			File.remove(path);
			output = File.create( path, 0644);
			output = File.open( path, FileSystem.O_RDWR );
			output.writeln("[");

			.iterateIntermediateFile(generated_export, false, null) using ( row ) {
				if( pendingComma ) {
					output.writeln(pendingComma);
				}
				output.write(row);
				pendingComma = ',';
			};
			
			output.writeln("]");
			output.flush();
			output.close();
		}
	}

	function setup {
		.exportPath = (Config.CachePath - 'Cache/') + 'Exports/';
		Directory.build(.exportPath);
	}

	function createMessage( object export, array exportedFiles ) {
		object message = null;
		
		if( export.emailflag ) {
			string body;

			object content = new Mail.MessageMultiPart();
			object text = new Mail.MessagePart();
			
			message = new Mail.Message();
			message.header = new Mail.MessageHeader();
			message.header.from.add( new Mail.Address(export.optionalAddress) );
			message.header.to.add( new Mail.Address(export.optionalAddress) );
			
			message.header.subject = I('Export {0:name} Completed').expand(export.name);
			message.header.date = Date.localDate(Date.GMTnow()).format( '%a, %d %b %Y %H:%M:%S %z' );

			message = MailUtilities.setOutgoingHeader(message,export.optionalAddress);

			body = I('Your export {0:name} has completed. Please find the export within the attached file(s).').expand(export.name);
			body = Regexp.replaceAll("\r\n", body, "\n");
			body = Regexp.replaceAll("\r", body, "\n");
			body = Regexp.replaceAll("\n", body, "\r\n");

			text.type = Mail.Mime.TYPETEXT;
			text.subtype = "plain";
			text.charset = "UTF-8";
			text.content = body;
			content.addPart(text);
			
			exportedFiles.each() using ( exportedFile ) {
				object part = new Mail.MessagePart();
				part.filepath = exportedFile;
				part.filename = File.name(exportedFile);
				part.type = Mail.Mime.TYPEAPPLICATION;
				part.subtype = "octet-stream";
				part.encoding = Mail.Encoding.ENCBINARY;
				content.addPart(part);
			};

			message.content = content;
		}
		return message;
	}
}

namespace modifies Workflow {
	class modifies Format {
		function structure {
			object format = self;
			array keys = [], values = [];

			if( format.errandId )    values['errand_id'] = I('Errand ID');
			if( format.fromAddress ) values['from_address'] = I('From Address');
			if( format.toAddress )   values['to_address'] = I('To Address');
			if( format.subject )     values['subject'] = I('Errand Subject');
			if( format.question )    values['question'] = I('Question');
			if( format.answer )      values['answer'] = I('Answer');
			if( format.arrived )     values['timestamp_arrived'] = I('Arrived');
			if( format.opened )      values['timestamp_opened'] = I('Opened');
			if( format.answered )    values['timestamp_answered'] = I('Answered');
			if( format.closed )      values['timestamp_closed'] = I('Closed');
			if( format.agentid )     values['agent_id'] = I('Agent ID');
			if( format.agentname )   values['agent_name'] = I('Agent Name');
			if( format.areaid )      values['area_id'] = I('Area ID');
			if( format.areaname )    values['area_name'] = I('Area Name');
			if( format.clientid )    values['client_id'] = I('Client ID');
			if( format.priority )    values['priority'] = I('Errand Priority');
			if( format.tags )        values['tag_names'] = I('Tags');
			
			values.eachWithIndex() using ( value, index ) {
				keys[] = values.getName(index);
			};

			return [
				'active_keys' => keys,
				'translations' => values
			];
		}
	}
	class modifies Export {
		function setSearchTerms( array positive, array negative ) {
			.setValue('positivesearchterms', String.base64encode(Serialize.toNative(positive)));
			.setValue('negativesearchterms', String.base64encode(Serialize.toNative(negative)));
		}
		function getPositiveSearchTerms {
			if( not .positivesearchterms ) {
				return [];
			}
			return Serialize.fromNative(String.base64decode(.positivesearchterms));
		}
		function getNegativeSearchTerms {
			if( not .negativesearchterms ) {
				return [];
			}
			return Serialize.fromNative(String.base64decode(.negativesearchterms));
		}
		function setEmailLists( array positive, array negative ) {
			.setValue('positiveEmailAddList', String.base64encode(Serialize.toNative(positive)));
			.setValue('negativeEmailAddList', String.base64encode(Serialize.toNative(negative)));
		}
		function getPositiveEmailLists {
			if( not .positivesearchterms ) {
				return [];
			}
			return Serialize.fromNative(String.base64decode(.positiveEmailAddList));
		}
		function getNegativeEmailLists {
			if( not .negativesearchterms ) {
				return [];
			}
			return Serialize.fromNative(String.base64decode(.negativeEmailAddList));
		}

		function updateProgress( object generated_export, number progress ) {
			if( generated_export.progress < progress ) {
				log(self, "Progress: $progress%");
				generated_export.setValue('progress', progress);
				generated_export.save();
			}
		}
		function runQuery( string query, number offset, number limit ) {
			string sql = query;
			sql = Regexp.replaceAll('{limit}', sql, "$limit");
			sql = Regexp.replaceAll('{offset}', sql, "$offset");
			monitor {
				return ObjRunObject.invoke('ObjectServer.query.rawSQL', [ 'sql' => sql ], new JSON.ArrayHandler(Exports.ExportResult));
			} handle {
				log(self, "Error running query: $sql (${err.str})");
			}
		}
		function fetchExportSize( string query ) {
			array results = ObjRunObject.rawQuery(query);
			return results[0]['export_size'];
		}
		function generateSQL {
			return .generateSQL('', false);
		}
		function generateSQL( string prefix, boolean aggregate ) {
			object deleted_tag = Workflow.Tag.fetch(Workflow.Errand.TAG_DELETED);
			
			object format = self.exportFormat;
			
			array selectClause = [];
			array leftJoins = [];
			array whereClause = [];
			array collapsable;
			
			boolean checkingErrandContents = (.getPositiveSearchTerms() or .getNegativeSearchTerms() ? true : false);
			boolean checkingFromAddress = (.getPositiveEmailLists() or .getNegativeEmailLists() ? true : false);
			
			// workflow_errands
			if( format.errandId ) selectClause[] = "errand.workflow_errand_id AS errand_id";
			if( format.arrived )  selectClause[] = "errand.timestampArrive AS _internal_timestamp_arrived";
			if( format.opened )   selectClause[] = "errand.timestampOpen AS _internal_timestamp_opened";
			if( format.answered ) selectClause[] = "errand.timestampLastAnswered AS _internal_timestamp_answered";
			if( format.closed )   selectClause[] = "errand.timestampClosed AS _internal_timestamp_closed";
			if( format.agentid )  selectClause[] = "errand.owner_fkey AS agent_id";
			if( format.areaid )   selectClause[] = "errand.targetArea_fkey AS area_id";
			if( format.clientid ) selectClause[] = "errand.client_fkey AS client_id";

			if( format.priority ) {
				selectClause[] = "priority.name AS priority";
				leftJoins['workflow_priorities AS priority'] = "errand.priority_fkey = priority.workflow_priority_id";
			}
			
			// workflow_errand_tags_links, workflow_tags
			if( format.tags ) {
				selectClause[] = "
					(SELECT array_to_string(array_agg(display), ', ') 
					 FROM workflow_tags 
					 WHERE workflow_tag_id IN (
							SELECT child_workflow_tag_id 
							FROM workflow_errand_tags_links 
							WHERE parent_workflow_errand_id=errand.workflow_errand_id AND
								child_workflow_tag_id NOT IN (SELECT workflow_tag_id FROM workflow_tags WHERE name like 'System%'))
					) AS tag_names
				";
			}

			// workflow_mail... ish.
			if( format.toAddress ) {
				selectClause[] = "
					(SELECT array_to_string(array_agg(emailAddress), ', ') 
					 FROM workflow_mailorigins
					 WHERE workflow_mailorigin_id IN (
						SELECT child_workflow_mailorigin_id 
						FROM workflow_mail_to_links 
						WHERE parent_workflow_mail_id=errand.mail_fkey)) AS to_address
				";
			}
			if( format.fromAddress or checkingFromAddress ) {
				selectClause[] = "
					(SELECT emailAddress
					 FROM workflow_mailorigins
					 WHERE workflow_mailorigin_id IN (
						SELECT from_fkey 
						FROM workflow_mails 
						WHERE workflow_mail_id=errand.mail_fkey)) AS " + (format.fromAddress ? 'from_address' : '_internal_from_address');
			}
			
			// workflow_simplemesssges
			if( format.subject or format.question or checkingErrandContents ) {
				leftJoins['workflow_simplemessages AS question'] = "errand.message_fkey = question.workflow_simplemessage_id";
				leftJoins['workflow_mails AS mail'] = "errand.mail_fkey = mail.workflow_mail_id";
				if( format.subject )  selectClause[] = "question.subject AS subject, mail.subject AS original_subject";
				if( format.question ) selectClause[] = "question.body AS question, mail.body AS original_question";
				if( checkingErrandContents ) {
					selectClause[] = "(question.subject || ' ' || question.body || ' ' || mail.subject || ' ' || mail.body) AS _internal_errand_text";
				}
			}
			if( format.answer ) {
				leftJoins['workflow_answers AS answer'] = "errand.answer_fkey = answer.workflow_answer_id";
				leftJoins['workflow_simplemessages AS answer_content'] = "answer.message_fkey = answer_content.workflow_simplemessage_id";
				selectClause[] = "answer_content.body AS answer";
			}

			// workflow_users
			if( format.agentname ) {
				leftJoins['workflow_users AS agent'] = "errand.owner_fkey = agent.workflow_user_id";
				selectClause[] = "(agent.username || ' (' || agent.loginname || ')') AS agent_name";
			}
			// workflow_areas
			if( format.areaname ) {
				leftJoins['workflow_areas AS area'] = "errand.targetArea_fkey = area.workflow_area_id";
				selectClause[] = "area.name AS area_name";
			}
			
			if( .start ) {
				whereClause[] = "errand.timestampArrive > ${.start}";
			}
			if( .finish ) {
				whereClause[] = "errand.timestampArrive < ${.finish}";
			}
			if( .areas ) {
				whereClause[] = "errand.targetArea_fkey IN (" + .areas.join(',') using ( area ) { return '' + area.id; } + ")";
			} else {
				whereClause[] = "errand.targetArea_fkey IN (" + Workflow.SystemGroup.areas(.systemGroup).join(',') using ( area ) { return '' + area; } + ")";
			}
			
			if( not .allerrandsflag ) {
				if( .positiveTagList or .negativeTagList ) {
					if( .positiveTagList ) {
						whereClause[] = "errand.workflow_errand_id IN (SELECT parent_workflow_errand_id FROM workflow_errand_tags_links WHERE child_workflow_tag_id IN (" + .positiveTagList.join(',') using ( tag ) {
							return '' + tag.id;
						} + "))";
					}
					if( .negativeTagList ) {
						whereClause[] = "errand.workflow_errand_id NOT IN (SELECT parent_workflow_errand_id FROM workflow_errand_tags_links WHERE child_workflow_tag_id IN (" + .negativeTagList.join(',') using ( tag ) {
							return '' + tag.id;
						} + "))";
					}
				}
			} else {
				whereClause[] = "errand.workflow_errand_id NOT IN (SELECT parent_workflow_errand_id FROM workflow_errand_tags_links WHERE parent_workflow_errand_id=errand.workflow_errand_id AND child_workflow_tag_id=${deleted_tag.id})";
			}
			
			leftJoins.map() using ( join, condition ) {
				collapsable[] = "LEFT JOIN $join ON $condition";
			};
			
			return 
				(prefix ? prefix : "SELECT " + selectClause.join(',')) + " " +
				"FROM workflow_errands AS errand " + 
				(leftJoins
					? collapsable.join(" ") + " "
					: ' ' ) +
				(whereClause 
					? "WHERE " + whereClause.join(' AND ')
					: '') +
				(aggregate ? '' : "ORDER BY workflow_errand_id ASC OFFSET {offset} LIMIT {limit}");
		}
		function generatePreview( object format ) {
			object actual_export = Workflow.Export.load(self.id);
			array list = [];
			array columns = [], order = [];
			object original_format = actual_export.exportFormat;
			number count = 1;
			
			actual_export.setValue('exportFormat', format);
			.runQuery(actual_export.generateSQL(), 0, 20).each() using ( row ) {
				string id = 'row-' + Date.GMTnow() + '-' + count;
				
				if( not columns ) columns = row.toOrder(format);
				list["$id"] = [ 'data' => row.toArray(format), 'id' => id ];
				order[] = id;
				count++;
			};
			actual_export.setValue('exportFormat', original_format);
			return [ 'list' => list, 'order' => order, 'columns' => columns ];
		}
		function run {
			object actual_export = Workflow.Export.load(self.id);
			object generated_export = new Workflow.GeneratedExports();
			object writer = Exports.DataWriter.createForExport(actual_export);
			number export_size = 0;
			string fetch_sql = actual_export.generateSQL();
			object message = null;
			array results = [];
			number limit = 500;
			number offset = 0;
			boolean keepRunning = true;

			log(self, "Starting export '${self.name}'");
			export_size = .fetchExportSize(actual_export.generateSQL('SELECT COUNT(errand.workflow_errand_id) AS export_size', true));
			log(self, "Export will be a maximum of $export_size rows.");
			
			actual_export.setValue('exportState', Workflow.Export.STATE_RUNNING);
			actual_export.save();

			generated_export.setValue('export', actual_export);
			generated_export.setValue('start', Date.GMTnow());
			generated_export.setValue('size', export_size);
			generated_export.save();
			
			writer.setTag("version-${generated_export.id}");
			writer.start();
			do {
				boolean resultSeen = false;
				actual_export = Workflow.Export.forceLoad(actual_export.id);
				if( actual_export.exportState == Workflow.Export.STATE_STOPPED ) {
					log(self, "Remote termination of export requested. Finishing.");
					keepRunning = false;
				} else {
					// Update the progress
					.updateProgress( generated_export, ((offset / (export_size + 0.0)) * 50).round() );
					// Run the data retrival
					resultSeen = writer.record(.runQuery(fetch_sql, offset, limit));
					offset += limit;
				}
			} while( resultSeen and keepRunning );


			if( keepRunning ) {
				log(self, "Totals: recorded: ${writer.recordedCount}; duplicate rows eliminated: ${writer.duplicateCount}");
				log(self, "Finishing export to file: ${writer.finishFiles()}");
				writer.finish(generated_export);
				log(self, "Files written - export '${actual_export.name}' complete.");
			
				message = Exports.createMessage( actual_export, writer.finishFiles() );
				if( message ) {
					log(self, "Sending export file${(writer.finishFiles().size() > 1 ? 's' : '')} to ${actual_export.optionalAddress}");
					MailUtilities.sendMessage( new Mail.Connection(), message );
				}

				log(self, "Recording generated report for UI.");
				generated_export.setValue('progress', 100);
				generated_export.setValue('size', writer.recordedCount);
				generated_export.setValue('finish', Date.GMTnow());
				generated_export.setValue('filename', writer.finishFiles().join(':'));
				generated_export.save();
				log(self, "Export recorded to object with id ${generated_export.id}.");

				actual_export = Workflow.Export.forceLoad(actual_export.id);
				actual_export.setValue('exportState', Workflow.Export.STATE_FINISHED);
				actual_export.save();
			} else {
				generated_export.delete();

				actual_export = Workflow.Export.forceLoad(actual_export.id);
				actual_export.setValue('exportState', Workflow.Export.STATE_IDLE);
				actual_export.save();
			}

		}
	}
}

Exports.setup();
