namespace Export {

/* function getSourceAreas() gets the source errand areas IDs for export */

function getSourceAreas (object exportAreas, number exportFlag){
		array idAreas = [];

		exportAreas and exportAreas.areas.each() using (areaItems){
			idAreas [ ] = areaItems.id;
		};
		
		if (not idAreas){
			if(exportFlag)
				Console.println("No source area list found for this export.");
			//return idAreas = ["No source area list found for this export."];
			return [];
		}

		return idAreas;
}

/* function getParsedData() parse the comma separated list of search terms and emailaddress for export */

 function getParsedData(string list){

		array searchData;

		if( list.length() )
			searchData = Regexp.split( "," , list );
		return searchData;
	}


/* function listErrandsByAllErrandsFlag() is invoked when allerrandsflag is set to true. searchflag 1 means it is invoked from backend script and 0 means invoked from app */

function listErrandsByAllErrandsFlag(object exportObj, number exportFlag) {
	
	array errandsList= [];
	
	number startDate = 0, endDate = 0;

	if(exportObj.start == 0 || exportObj.finish == 0) {
			if(exportFlag)
				Console.println("Time interval is not specified for this export.");
			else	return [];
	}
	
	startDate = (exportObj.start <0 ? (Date.now() + exportObj.start):exportObj.start);
	endDate = (exportObj.finish <0 ? (Date.now() + exportObj.start):exportObj.finish);
	
		if(exportFlag == 0){
			Workflow.Errand.listLimitedErrandsWithinIntervalForExport(self.getSourceAreas(exportObj,0),startDate,endDate).each() using (errandItem)	{
				errandsList[] = errandItem.id;
		
			};

		}
		else if (exportFlag == 1){

			Workflow.Errand.listErrandsWithinIntervalForExport(self.getSourceAreas(exportObj,1),startDate,endDate).each() using (errandItem)	{
				errandsList[] = errandItem.id;
		
			};

		}
		if(not errandsList) {
			if(exportFlag)
				Console.println("No errands found in the time interval for this export.");
			else return [];
			
		}
	

	return errandsList;

}

/* function listErrandsBySearch() is invoked when allerrandsflag is false, that is search criteria is chosen. searchflag 1 means it is invoked from backend script and 0 means invoked from app */

function listErrandsBySearch(object exportObj, array p_email_list, array n_email_list, array p_word_list, array n_word_list, number searchFlag){

	array errandsList=[],positive_list_email = [],negative_list_email = [],positive_list_body = [],negative_list_body = [] ;
	array positive = [],negative = [];
	array exportAreas = self.getSourceAreas(exportObj,0);
	number startDate = 0, endDate = 0;
	
	if(exportObj.start == 0 || exportObj.finish == 0) {
			if(searchFlag)
				Console.println("Time interval is not specified for this export.");
				return [];
	}
		
	startDate = (exportObj.start <0 ? (Date.now() + exportObj.start):exportObj.start);
	endDate = (exportObj.finish <0 ? (Date.now() + exportObj.start):exportObj.finish);

	if( p_email_list.size() )
		positive_list_email = Workflow.Errand.errandsForMatchingEmailAddress(exportAreas,startDate,endDate,'(' + p_email_list.join('|') + ')');
	
	if( n_email_list.size() )
		negative_list_email = Workflow.Errand.errandsForMatchingEmailAddress(exportAreas,startDate,endDate,'(' + n_email_list.join('|') + ')');
	
	if( p_word_list.size() )
		positive_list_body = Workflow.Errand.errandsForMatchingEmailBody(exportAreas,startDate,endDate,'(' + p_word_list.join('|') + ')');
	
	if( n_word_list.size() ) 
		negative_list_body = Workflow.Errand.errandsForMatchingEmailBody(exportAreas,startDate,endDate,'(' + n_word_list.join('|') + ')');
	

// Join the lists
	positive = positive_list_email.append(positive_list_body);
	negative = negative_list_email.append(negative_list_body);
	
	
// We can now do the queries over the errands that match

	if(searchFlag == 0){
	

		Workflow.Errand.listErrandsForExportPreview(exportAreas,exportObj.start,exportObj.finish,(positive ? 1 : 0), (positive ? positive : [0]), (negative ? 1 : 0), (negative ? negative : [0])).each() using( list ){

			errandsList[] = list.id;
		};

	}


	else {
		Workflow.Errand.listErrandsForExportScript(exportAreas,exportObj.start,exportObj.finish,(positive ? 1 : 0), (positive ? positive : [0]), (negative ? 1 : 0), (negative ? negative : [0])).each() using( list ){

			errandsList[] = list.id;
		};
	}

	return errandsList;

}


/* function listExportFormats() get all the selected formats the export will use */

 function listExportFormats(number idformat){

	array formatFields = Workflow.Format.listFieldsByFormat(idformat);

		return formatFields;
}

/* function processExportData() does the actual processing of export data. From this function generateExportInfo() in Workflow.fe is called to save current progress of export */

function processExportData(object exportObj, array errandsList,array formatFields, number exportFlag){
		object exportInfo;
		number totalErrands = 0;
		number progress = 0;
		number errandsProcessed = 0;
		number _exportStart = 0, _exportEnd = 0;
		string filename = "";
		array exportErrands = [];
		array temp = [];
		object errandObj;

		if(exportFlag){  //the export is for backend script.
			_exportStart = Date.now();
			totalErrands = errandsList.size();
		
			exportInfo = Workflow.GeneratedExports.generateExportInfo(exportObj,filename,_exportStart,_exportEnd,totalErrands,progress);
		}

		errandsList.each() using (errandItem)	{
		
		errandObj = Workflow.Errand.load(errandItem);
		
		errandsProcessed ++;	

		if(Array.keyExists(formatFields, "errandId") ) {

			temp[ "errandId" ] = "" + errandItem;
		}

		if(Array.keyExists(formatFields, "fromAddress") ){

			temp[ "fromAddress" ] = "" + errandObj.mail.from.emailAddress;
		}
			
		if(Array.keyExists(formatFields, "toAddress") ){
			array receiverList;
			errandObj.mail.to.each() using (value){
				 receiverList[ ] = value.emailAddress;
			};
			temp[ "toAddress" ] = receiverList.join(',');
		}
			
		if(Array.keyExists(formatFields, "subject") ){

			temp[ "subject" ] = "" + errandObj.message.subject;
		}
		
		if(Array.keyExists(formatFields, "question") ) {

			temp[ "question" ] = "" + errandObj.message.body;
		}

		if(Array.keyExists(formatFields, "answer") ) {

			temp[ "answer" ] = "" +(errandObj.answer ? (errandObj.answer.message?errandObj.answer.message.body:"null") : "null");

		}
		
		if(Array.keyExists(formatFields, "arrived") ) {

			temp[ "arrived" ] = Date.date(errandObj.timestampArrive).format("%Y/%m/%d") ;
		}	
		
		if(Array.keyExists(formatFields, "opened") ) {

			temp[ "opened" ]= (errandObj.timestampOpen > 0 ?Date.date(errandObj.timestampOpen).format("%Y/%m/%d"):"null") ;
		}

		if(Array.keyExists(formatFields, "answered") ) {

			temp[ "answered" ] = (errandObj.timestampLastAnswered>0? Date.date(errandObj.timestampLastAnswered).format("%Y/%m/%d"):"null") ;
		}

		if(Array.keyExists(formatFields, "closed") ) {

			temp[ "closed" ] = (errandObj.timestampClosed >0?Date.date(errandObj.timestampClosed).format("%Y/%m/%d"):"null");
		}

		if(Array.keyExists(formatFields, "agentid") ) {

			temp[ "agentid" ] = (errandObj.owner?errandObj.owner.id: 0);
		
		}

		if(Array.keyExists(formatFields, "agentname") ) {

			temp[ "agentname" ] =  (errandObj.owner?errandObj.owner.username: "null");
		}
	
		if(Array.keyExists(formatFields, "areaid") ) {
			temp[ "areaid" ] = "" + errandObj.targetArea.id;
		}
		
		if(Array.keyExists(formatFields, "areaname") ) {
			temp[ "areaname" ] = errandObj.targetArea.name;
		}
			
		if(Array.keyExists(formatFields, "tags") ){
			array tagList;
			errandObj.tags.each() using (value){
				tagList[] = value.display;
			};
			temp[ "tags" ] = tagList.join(',');
		}

		if(Array.keyExists(formatFields, "clientid") ){

			temp[ "clientid" ] = "" + errandObj.client.id;
		}

		if(Array.keyExists(formatFields, "priority") ) {
			
			temp[ "priority" ] = "" + (errandObj.priority?errandObj.priority.name : "null"); 
		}	
			
			exportErrands[] = temp;
			temp[] = "";

		if(exportFlag){
			progress = (errandsProcessed * 100) / totalErrands;
			exportInfo.setValue('progress',progress);
			exportInfo.save();
		}
	};

	errandsProcessed = 0;
	progress = 0;
	
	if(exportFlag){
		self.saveExportsInfo(exportObj, exportInfo,  exportErrands);
	}
	return exportErrands;
}

function saveExportsInfo( object exportObj,object exportInfo, array exportErrands){
		
		string filename = "";
		
		
		if(exportObj.type == 0 ){ // export to excel
		
			filename = self.generateXLS(exportErrands,exportObj);
		}
		else if(exportObj.type == 1 ){ // export to csv
			
			filename = self.generateCSV(exportErrands,exportObj);
		}
		else if(exportObj.type == 2 ){ // export to xml
			
			filename = self.generateXML(exportErrands,exportObj);
		}

		exportInfo.setValue('filename',filename);
		exportInfo.setValue('finish', Date.now());

		exportInfo.save();
		
		/* the export is finished and progress is 100 %, so  the export scheduled flag is set to false  */

		exportObj.setValue('shouldgenerateflag', false);
		exportObj.save();
		
		if(exportObj.emailflag == true)
			self.sendExportToOwner(exportObj, fileName);
		
	}

   
	function createExportMessage( object mail ) {

		object message = new Mail.Message();
		object text = new Mail.MessagePart();
		object to = new Mail.Address( mail.to[0].emailAddress);
		object from = new Mail.Address(mail.from.emailAddress );

		message.header = new Mail.MessageHeader();

		
	
		message.header.from.add( from  );
		message.header.to.add( to);
		message.header.subject = mail.subject;
		message.header.date = Date.localDate( Date.GMTnow() ).format( '%a, %d %b %Y %H:%M:%S %z' );
	
		
		message = MailUtilities.setOutgoingHeader(message,mail.from.emailAddress);
	
		text.type = Mail.Mime.TYPETEXT;
		text.subtype = "plain";
		text.charset = "UTF-8";
		text.content = mail.body;
	
		if( not mail.hasAttachments ) {
			message.content = text;
		} else {
		object content = new Mail.MessageMultiPart();
		content.subtype = "mixed";
		content.addPart( text );
		mail.attachments.each() using ( attachment ) {
			object part = new Mail.MessagePart();
			
			part.filepath =  "${attachment.localName}";
			part.filename = attachment.fileName;
			part.type = Mail.Mime.TYPEAPPLICATION;
			part.subtype = "octet-stream";
			part.encoding = Mail.Encoding.ENCBINARY;
			content.addPart( part );
		};
		
		message.content = content;
		}
	
		return message;
	}


	function sendInternalMsg(object exportObj){

		object simpleMessage = new Workflow.SimpleMessage();
		object inboxMessage = new Workflow.InternalMessage();
		object sentMessage = new Workflow.InternalMessage();
		object  exportOwnerUserObj;
		number timestampSent = Date.GMTnow();		
		object objSender= Workflow.User.currentWorkflowUser;
		
		
		
		exportOwnerUserObj = Workflow.User.load(exportObj.createdby.id);
		
		simpleMessage.setValue( 'subject', "Cention Exports" );
		simpleMessage.setValue( 'body', "Export is finished." );
		simpleMessage.save();

		
		sentMessage.setValue( 'type', Workflow.InternalMessageType.create( 'Urgent' ) );
		sentMessage.setValue( 'timestampSent', Date.GMTnow() );
		sentMessage.setValue( 'message', simpleMessage );
		sentMessage.setValue( 'folder', Workflow.InternalFolder.fetch(Workflow.InternalFolder.SENT) );
		sentMessage.setValue( 'origin', objSender );
		sentMessage.save();
		
		inboxMessage.setValue( 'type', Workflow.InternalMessageType.create( 'Urgent' ) );
		inboxMessage.setValue( 'timestampSent', Date.GMTnow() );
		inboxMessage.setValue( 'message', simpleMessage );
		inboxMessage.setValue( 'folder', Workflow.InternalFolder.fetch(Workflow.InternalFolder.INBOX));
		inboxMessage.setValue( 'targets', [exportOwnerUserObj]);
		inboxMessage.save();


	}



	function sendExportToOwner(object export, string exportfile){
		
		
		object mail,mailAttachment;
 		object objMailSender,ObjMailReceiver;
 		object exportSender;
 		array attachments = [];
 		string path ;
		string addrToSend= "",addrFrom = "";
 		string exportsDirectory = (Config.CachePath - 'Cache/') + 'Exports';
 
 		string subject = "Cention Exports";
 		string msgContent = "Hi,Your order for export is completed and the generated file is attached herewith. Thanks a lot.";

		object exportOwnerEmail = Workflow.User.load(export.createdby.id);
		object connection = new Mail.Connection();
	
		
		addrToSend = (exportOwnerEmail.person ? (exportOwnerEmail.person.email?exportOwnerEmail.person.email.emailAddress:""):"");

		addrFrom = "sys@cention.se";

 		if (addrToSend == "") {
			Console.println("The export owner provides no email address.");
			return;
		}
		else {
		
 			objMailSender =  new Workflow.MailOrigin();
 			ObjMailReceiver = new Workflow.MailOrigin();
		
		
		
 			objMailSender.setValue( 'emailAddress', addrToSend );
 			objMailSender.save();
 		
			ObjMailReceiver.setValue( 'emailAddress', addrFrom );
 			ObjMailReceiver.save();

 			mail = new Workflow.Mail();
 
 			mail.setValue( 'to', [objMailSender] );
 			mail.setValue( 'from', ObjMailReceiver );
 			mail.setValue( 'subject', subject );
 			mail.setValue( 'body', msgContent ) ;
 			mail.setValue( 'hasAttachments', true );
 	
 			mailAttachment = new Workflow.MailAttachment();
 
 			path = "${exportsDirectory}";
 		
 			mailAttachment.setValue( 'localName', "${path}/${exportfile}");
 			mailAttachment.setValue( 'fileName', "${exportfile}");
 			mailAttachment.setValue( 'majorType', Mail.Mime.toString( Mail.Mime.TYPETEXT ) );
 			mailAttachment.setValue( 'minorType', "plain" );
 			mailAttachment.save();
 			mail.attachmentsAdd( mailAttachment );
 
 			attachments[] = mailAttachment;
		
 			mail.setValue( 'attachments', attachments );
 			mail.save();
 		

 			Console.println("Finished.");
 			Console.println("Sending E-mail to export owner...");
 
 			MailUtilities.sendMessage(connection,self.createExportMessage(mail) );
		
 			Console.println("Sending internal message to the user...");

			self.sendInternalMsg(export);
		}

	}

	function saveExports(string filename, string results){
		string path ;
		string exportsDirectory = (Config.CachePath - 'Cache/') + 'Exports';

		path = "${exportsDirectory}";

			not Directory.open( path ) and Directory.make( path, 0755 );

			File.create( "${path}/${filename}" ) using ( file ) {
				file.writeln( results );
			};

	}
	

/*************Function for match Generating CSV file*****************************/	
/*************Function for match Generating CSV file
Created by : Kreshano Dutta
************************************************/	

	function generateCSV(array dataForFile, object export)
	{
		array collumnHeader;
		string resultCSV = "",currentTimeStamp="",fileName = "";
		object fileWriteObject;
		boolean flag;
		number count = 0;

		
		dataForFile and dataForFile[0].each() using( temp )
		{
			collumnHeader[] = Array.getName(dataForFile[0],count);
			count++;
		};

	
		dataForFile.each() using ( tempArray )
		{
			flag = false;
			collumnHeader.each() using ( key ) 
			{
				if( flag )
					resultCSV += ",";
				resultCSV += tempArray[ key ];
				flag = true;
			};
			resultCSV += "\n";
		};
		
		currentTimeStamp = "" + Date.GMTnow();
		fileName = export.name + currentTimeStamp + ".csv";

		self.saveExports(fileName, resultCSV );
		return fileName;
	}



/*************Function for match Generating XLS file
Created by : Kreshano Dutta
************************************************/	
	function generateXLS( array dataForFile, object export )
	{
		string resultXLS = "",fileName = "";
		object fileWriteObject;
		array collumnHeader;
		string currentTimeStamp = "" + Date.GMTnow();
		number count = 0;

		resultXLS =  "<html>\n";
		resultXLS += "<head>\n";
		resultXLS += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n";
		resultXLS += "</head>\n";
		
		resultXLS += "<body>\n";
		resultXLS += "<table border=1>\n";
	
		resultXLS += "<tr>\n";

		
		dataForFile and dataForFile[0].each() using( temp )
		{
			collumnHeader[] = Array.getName(dataForFile[0],count);
			count++;
		};
		
		
		collumnHeader.each() using ( collumn )
		{
			resultXLS += "<td>" + collumn + "</td>";
		};

		resultXLS += "</tr>\n";
		
		dataForFile.each() using ( tempArray )
		{
			resultXLS += "<tr>\n";
			collumnHeader.each() using ( key ) 
			{
				resultXLS += "<td>" + tempArray[key] + "</td>\n";
			};
			resultXLS += "</tr>\n";	
		};
		
		
		resultXLS += "</table>\n";
		resultXLS += "</body>\n";	
		resultXLS +=  "</html>";	
		
		fileName = export.name + currentTimeStamp + ".xls";
		
		self.saveExports(fileName, resultXLS );
		return fileName;
	}


/*************Function for match Generating XML file
Created by : Kreshano Dutta
************************************************/	

	function generateXML(array dataForFile, object export )
	{
		array tagName;
		string resultXML = "",fileName = "" ;
		object fileWriteObject;
 		string currentTimeStamp = "" + Date.GMTnow();	
		number count = 0;

		
		dataForFile and dataForFile[0].each() using( temp )
		{
			tagName[] = Array.getName(dataForFile[0],count);
			count++;
		};

		
		resultXML += "<root>";
		resultXML += "\n";

		dataForFile.each() using ( tempArray )
		{
			resultXML += "<data>" ;	
			resultXML += "\n";
			tagName.each() using ( key ) 
			{
				resultXML += "<" + key + ">" + tempArray[ key ] + "</" + key + ">";	
				resultXML += "\n";
			};
			resultXML +="</data>";	
			resultXML += "\n";
		};
	
		resultXML += "</root>";
		resultXML += "\n";

		fileName = export.name + currentTimeStamp + ".xml";
		
		self.saveExports(fileName, resultXML );
		return fileName;
	}
	
}