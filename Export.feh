uses "console";
uses "ExportUtilities.fe";
namespace Export {

/* function getSourceAreas() gets the source errand areas IDs for export */

array uniqueRows;//This array holds exports which is generated processing a fixed number of errands each time. This list itself may hold duplicate entries. So, It needs further duplicate removal.



function getSourceAreas (object exportAreas, number exportFlag){
		array idAreas = [];

		exportAreas and exportAreas.areas.each() using (areaItems){
			idAreas [ ] = areaItems.id;
		};
		
		if (not idAreas){
			if(exportFlag)
				Console.println("No source area list found for this export.");
			
			else return [];
		}

		return idAreas;
}

/* function getParsedData() parse the comma separated list of search terms and emailaddress for export */

 function getParsedData(string list){

		array searchData = [];

		if( list.length() )
			searchData = Regexp.split( "," , list );
		return searchData;
	}


/* function listErrandsByAllErrandsFlag() is invoked when allerrandsflag is set to true. searchflag 1 means it is invoked from backend script and 0 means invoked from app */

function listErrandsByAllErrandsFlag(object exportObj, number limit, number offset, number exportFlag) {
	
	array errandsList= [];
	
	number startDate = 0, endDate = 0;
      
	if(exportObj.start == 0 || exportObj.finish == 0) {
			if(exportFlag)
				Console.println("Time interval is not specified for this export.");
			else	return [];
	}
	
	startDate = (exportObj.start <0 ? (Date.GMTnow() + exportObj.start):exportObj.start);
	endDate = (exportObj.finish <0 ? (Date.GMTnow() + exportObj.finish):exportObj.finish);
	
		

			Workflow.Errand.listErrandsWithinIntervalForExportWithLimit(self.getSourceAreas(exportObj,exportFlag),startDate,endDate,limit,offset).each() using (errandItem)	{
				errandsList[] = errandItem.id;
		
			};

		
		if(not errandsList) {
			if(exportFlag)
				Console.println("No errands found in the time interval for this export.");
			else return [];
			
		}
	

	return errandsList;

}

/* this function is invoked only for backend script purpose */

function countErrandsBySearch(object exportObj, array p_email_list, array n_email_list, array p_word_list, array n_word_list,number limit,number offset){

	array errandsList=[],positive_list_email = [],negative_list_email = [],positive_list_body = [],negative_list_body = [] ;
	array positive = [],negative = [];
	array exportAreas = self.getSourceAreas(exportObj,1);
	number startDate = 0, endDate = 0;
	
	if(exportObj.start == 0 || exportObj.finish == 0) {
			if(searchFlag)
				Console.println("Time interval is not specified for this export.");
				return [];
	}
		
	startDate = (exportObj.start <0 ? (Date.GMTnow() + exportObj.start):exportObj.start);
	endDate = (exportObj.finish <0 ? (Date.GMTnow() + exportObj.finish):exportObj.finish);

	if( p_email_list.size() )
		positive_list_email = Workflow.Errand.errandsForMatchingEmailAddress(exportAreas,startDate,endDate,'(' + p_email_list.join('|') + ')');
	
	if( n_email_list.size() )
		negative_list_email = Workflow.Errand.errandsForMatchingEmailAddress(exportAreas,startDate,endDate,'(' + n_email_list.join('|') + ')');
	
	if( p_word_list.size() )
		positive_list_body = Workflow.Errand.errandsForMatchingEmailBody(exportAreas,startDate,endDate,'(' + p_word_list.join('|') + ')');
	
	if( n_word_list.size() ) 
		negative_list_body = Workflow.Errand.errandsForMatchingEmailBody(exportAreas,startDate,endDate,'(' + n_word_list.join('|') + ')');
	

// Join the lists
	positive = positive_list_email.append(positive_list_body);
	negative = negative_list_email.append(negative_list_body);

	return Workflow.Errand.countErrandsForExportScript(exportAreas,startDate,endDate,(positive ? 1 : 0), (positive ? positive : [0]), (negative ? 1 : 0), (negative ? negative : [0]));
	

}



/* function listErrandsBySearch() is invoked when allerrandsflag is false, that is search criteria is chosen. searchflag 1 means it is invoked from backend script and 0 means invoked from app */

function listErrandsBySearch(object exportObj, array p_email_list, array n_email_list, array p_word_list, array n_word_list,number limit,number offset, number searchFlag){

	array errandsList=[],positive_list_email = [],negative_list_email = [],positive_list_body = [],negative_list_body = [] ;
	array positive = [],negative = [];
	array exportAreas = self.getSourceAreas(exportObj,searchFlag);
	number startDate = 0, endDate = 0;
	
	if(exportObj.start == 0 || exportObj.finish == 0) {
			if(searchFlag)
				Console.println("Time interval is not specified for this export.");
				return [];
	}
		
	startDate = (exportObj.start <0 ? (Date.GMTnow() + exportObj.start):exportObj.start);
	endDate = (exportObj.finish <0 ? (Date.GMTnow() + exportObj.finish):exportObj.finish);

	if( p_email_list.size() )
		positive_list_email = Workflow.Errand.errandsForMatchingEmailAddress(exportAreas,startDate,endDate,'(' + p_email_list.join('|') + ')');
	
	if( n_email_list.size() )
		negative_list_email = Workflow.Errand.errandsForMatchingEmailAddress(exportAreas,startDate,endDate,'(' + n_email_list.join('|') + ')');
	
	if( p_word_list.size() )
		positive_list_body = Workflow.Errand.errandsForMatchingEmailBody(exportAreas,startDate,endDate,'(' + p_word_list.join('|') + ')');
	
	if( n_word_list.size() ) 
		negative_list_body = Workflow.Errand.errandsForMatchingEmailBody(exportAreas,startDate,endDate,'(' + n_word_list.join('|') + ')');
	

// Join the lists
	positive = positive_list_email.append(positive_list_body);
	negative = negative_list_email.append(negative_list_body);
	
	

		Workflow.Errand.listErrandsForExportScriptWithLimit(exportAreas,startDate,endDate,(positive ? 1 : 0), (positive ? positive : [0]), (negative ? 1 : 0), (negative ? negative : [0]),limit,offset).each() using( list ){

			errandsList[] = list.id;
		};
	

	return errandsList;

}

function debug( string str, void p2 ) {

	Console.println("$p2: $str");
}


/* function listExportFormats() get all the selected formats the export will use */

 function listExportFormats(number idformat){

	array formatFields = Workflow.Format.listFieldsByFormat(idformat);	
	return formatFields;
}

/* function processExportData() does the actual processing of export data. From this function generateExportInfo() in Workflow.fe is called to save current progress of export */

function processExportData(object exportObj, array errandsList,array formatFields,number totalErrands, number _offset, number exportFlag, string fileName){
		object exportInfo;
		number progress = 0;
		number errandsProcessed = _offset;
		number _exportStart = 0, _exportEnd = 0;
		string filename = "";
		array exportErrands = [];
		array temp = [];
		object errandObj;

		if(exportFlag){  //the export is for backend script.
			_exportStart = Date.now();
			//totalErrands = errandsList.size();
		
			exportInfo = Workflow.GeneratedExports.generateExportInfo(exportObj,filename,_exportStart,_exportEnd,totalErrands,progress);
		}

		
		//Console.println("processed Errands are : "+errandsList);
		errandsList.each() using (errandItem)	{
		
			errandObj = Workflow.Errand.load(errandItem);
			
			errandsProcessed ++;	
			Console.println("Processed $errandsProcessed errands...");
	
			if(Array.keyExists(formatFields, "errandId") ) {
	
				temp[ "Errand Id" ] = "" + errandItem;
			}
	
			if(Array.keyExists(formatFields, "fromAddress") ){
				if(errandObj.mail){
					temp[ "From" ] = "" + errandObj.mail.from.emailAddress;
				}
			}
				
			if(Array.keyExists(formatFields, "toAddress") ){
				array receiverList;
				errandObj.mail.to.each() using (value){
					receiverList[ ] = value.emailAddress;
				};
				temp[ "To" ] = receiverList.join(',');
			}
				
			if(Array.keyExists(formatFields, "subject") ){
	
				temp[ "Subject" ] = "" + errandObj.message.subject;
			}
			
			if(Array.keyExists(formatFields, "question") ) {
	
				temp[ "Question" ] = "" + errandObj.message.body;
			}
	
			if(Array.keyExists(formatFields, "answer") ) {
	
				temp[ "Answer" ] = "" +(errandObj.answer ? (errandObj.answer.message?errandObj.answer.message.body:"-") : "-");
	
			}
			
			if(Array.keyExists(formatFields, "arrived") ) {
	
				temp[ "Arrived" ] = formatDateTime(errandObj.timestampArrive) ;
			}	
			
			if(Array.keyExists(formatFields, "opened") ) {
	
				temp[ "Opened" ]= (errandObj.timestampOpen > 0 ?formatDateTime(errandObj.timestampOpen):"-") ;
			}
	
			if(Array.keyExists(formatFields, "answered") ) {
	
				temp[ "Answered" ] = (errandObj.timestampLastAnswered>0? formatDateTime(errandObj.timestampLastAnswered):"-") ;
			}
	
			if(Array.keyExists(formatFields, "closed") ) {
	
				temp[ "Closed" ] = (errandObj.timestampClosed >0?formatDateTime(errandObj.timestampClosed):"-");
			}
	
			if(Array.keyExists(formatFields, "agentid") ) {
	
				temp[ "Agent Id" ] = "" +(errandObj.owner?errandObj.owner.id: 0);
			
			}
	
			if(Array.keyExists(formatFields, "agentname") ) {
	
				temp[ "Agent name" ] =  (errandObj.owner?errandObj.owner.username: "-");
			}
		
			if(Array.keyExists(formatFields, "areaid") ) {
				temp[ "Area Id" ] = "" + errandObj.targetArea.id;
			}
			
			if(Array.keyExists(formatFields, "areaname") ) {
				temp[ "Area name" ] = errandObj.targetArea.name;
			}
				
			if(Array.keyExists(formatFields, "tags") ){
				array tagList;
				errandObj.tags.each() using (value){
					tagList[] = value.display;
				};
				temp[ "Tags" ] = tagList.join(',');
			}
	
			if(Array.keyExists(formatFields, "clientid") ){
	
				temp[ "Client Id" ] = "" + errandObj.client.id;
			}
	
			if(Array.keyExists(formatFields, "priority") ) {
				
				temp[ "Priority" ] = "" + (errandObj.priority?errandObj.priority.name : "-"); 
			}	
				
			exportErrands[] = temp;
			temp = [];
	
			
	};

	if(exportFlag and totalErrands){				
				
				progress = (errandsProcessed * 100) / totalErrands;
				exportInfo.setValue('progress',progress);
				exportInfo.save();

				if ( _offset == 0 and progress != 100) {
					self.saveExportsInfo(exportObj, exportInfo,  exportErrands,"start",fileName);
				}
				else if ( _offset == 0 and progress == 100 ){
					self.saveExportsInfo(exportObj, exportInfo,  exportErrands,"complete",fileName);
				}
				else if ( _offset > 0 and progress < 100 ){
					self.saveExportsInfo(exportObj, exportInfo,  exportErrands,"middle",fileName);

				}				
				else if ( progress >= 100 ) {
					self.saveExportsInfo(exportObj, exportInfo,  exportErrands,"end",fileName);
				}				
	}

	
	return exportErrands;
}


function saveExportsInfo( object exportObj,object exportInfo, array exportErrands, string status,string fileName){
		
		
		string currentTimeStamp = self.getTimestamp();		

		
		if(exportObj.type == 0 ){ // export to excel
		
			
			self.uniqueRows = Array.append(self.uniqueRows,self.uniqueRow(exportErrands));
			if ( "complete" == status or "end" == status) {		
				fileName = fileName + ".xls";			
				self.generateXLS(self.uniqueRows,exportObj,"complete",fileName);
				
			}			
		}
		else if(exportObj.type == 1 ){ // export to csv

			self.uniqueRows = Array.append(self.uniqueRows,self.uniqueRow(exportErrands));
			if ( "complete" == status or "end" == status) {		
				fileName = fileName + ".csv";
				self.generateCSV(exportErrands,exportObj,"complete",fileName);
			}			
			
		}
		else if(exportObj.type == 2 ){ // export to xml

			self.uniqueRows = Array.append(self.uniqueRows,self.uniqueRow(exportErrands));
			if ( "complete" == status or "end" == status ) {		
				fileName = fileName + ".xml";
				self.generateXML(exportErrands,exportObj,"complete",fileName);
			}			
			
		}
		

		if ( "complete" == status or "end" == status ) {
			exportInfo.setValue('filename',fileName);
			exportInfo.setValue('finish', Date.now());
			exportInfo.save();		
		/* the export is finished and progress is 100 %, so  the export scheduled flag is set to false  */

			exportObj.setValue('shouldgenerateflag', false);
			exportObj.save();
		
			if(exportObj.emailflag == true){
				Console.println("Sending Export to owner....");
				self.sendExportToOwner(exportObj, fileName);
			}
		}
		
	}

   
	function createExportMessage( object mail ) {

		object message = new Mail.Message();
		object text = new Mail.MessagePart();
		object to = new Mail.Address( mail.to[0].emailAddress);
		object from = new Mail.Address(mail.from.emailAddress );
		message.header = new Mail.MessageHeader();

		
	
		message.header.from.add( from  );
		message.header.to.add( to);
		message.header.subject = mail.subject;
		message.header.date = Date.localDate( Date.GMTnow() ).format( '%a, %d %b %Y %H:%M:%S %z' );
	
		
		message = MailUtilities.setOutgoingHeader(message,mail.from.emailAddress);
	
		text.type = Mail.Mime.TYPETEXT;
		text.subtype = "plain";
		text.charset = "UTF-8";
		text.content = mail.body;
	
		if( not mail.hasAttachments ) {
			message.content = text;
		} else {
		object content = new Mail.MessageMultiPart();
		content.subtype = "mixed";
		content.addPart( text );
		mail.attachments.each() using ( attachment ) {
			object part = new Mail.MessagePart();
			
			part.filepath =  "${attachment.localName}";
			part.filename = attachment.fileName;
			part.type = Mail.Mime.TYPEAPPLICATION;
			part.subtype = "octet-stream";
			part.encoding = Mail.Encoding.ENCBINARY;
			content.addPart( part );
		};
		
		message.content = content;
		}
	
		return message;
	}


	function sendInternalMsg(object exportObj){

		object objSender; 
		object simpleMessage = new Workflow.SimpleMessage();
		object inboxMessage = new Workflow.InternalMessage();
		object sentMessage = new Workflow.InternalMessage();
		object  exportOwnerUserObj;
		number timestampSent = Date.GMTnow();		
		

		
		exportOwnerUserObj = Workflow.User.load(exportObj.createdby.id);
		objSender = Workflow.User.fetchUserObject(exportObj.createdby.id);

		simpleMessage.setValue( 'subject', "Cention Exports" );
		simpleMessage.setValue( 'body', "Export is finished." );
		simpleMessage.save();

		
		sentMessage.setValue( 'type', Workflow.InternalMessageType.create( 'Urgent' ) );
		sentMessage.setValue( 'timestampSent', Date.GMTnow() );
		sentMessage.setValue( 'message', simpleMessage );
		sentMessage.setValue( 'folder', Workflow.InternalFolder.fetch(Workflow.InternalFolder.SENT) );
		sentMessage.setValue( 'origin', objSender );
		sentMessage.save();
		
		inboxMessage.setValue( 'type', Workflow.InternalMessageType.create( 'Urgent' ) );
		inboxMessage.setValue( 'timestampSent', Date.GMTnow() );
		inboxMessage.setValue( 'message', simpleMessage );
		inboxMessage.setValue( 'folder', Workflow.InternalFolder.fetch(Workflow.InternalFolder.INBOX));
		inboxMessage.setValue( 'targets', [exportOwnerUserObj]);
		inboxMessage.setValue( 'origin', objSender );
		inboxMessage.save();


	}



	function sendExportToOwner(object export, string exportfile){
		
		
		object mail,mailAttachment;
 		object objMailSender,ObjMailReceiver;
 		object exportSender;
 		array attachments = [];
 		string path ;
		string addrToSend= "",addrFrom = "";
 		string exportsDirectory = (Config.CachePath - 'Cache/') + 'Exports';
 
 		string subject = "Cention Exports";
 		string msgContent = I('Your export {0:1} has been completed. Please find it attached to this email.').expand(export.name);

		object exportOwnerEmail = Workflow.User.load(export.createdby.id);
		object connection = new Mail.Connection();
	
		
		addrToSend = (exportOwnerEmail.person ? (exportOwnerEmail.person.email?exportOwnerEmail.person.email.emailAddress:""):"");
		if( export.optionalAddress ) {
			addrToSend = export.optionalAddress;
		}
		
		addrFrom = "no-reply@cention.se";

 		if (addrToSend == "") {
			Console.println("The export owner provides no email address.");
			return;
		}
		else {
		
			Console.println("Sending export from $addrFrom to $addrToSend");
 			objMailSender =  new Workflow.MailOrigin();
 			ObjMailReceiver = new Workflow.MailOrigin();
		
 			objMailSender.setValue( 'emailAddress', addrToSend );
 			objMailSender.save();
 		
			ObjMailReceiver.setValue( 'emailAddress', addrFrom );
 			ObjMailReceiver.save();

 			mail = new Workflow.Mail();
 
 			mail.setValue( 'to', [objMailSender] );
 			mail.setValue( 'from', ObjMailReceiver );
 			mail.setValue( 'subject', subject );
 			mail.setValue( 'body', msgContent ) ;
 			mail.setValue( 'hasAttachments', true );
 	
 			mailAttachment = new Workflow.MailAttachment();
 
 			path = "${exportsDirectory}";
 		
 			mailAttachment.setValue( 'localName', "${path}/${exportfile}");
 			mailAttachment.setValue( 'fileName', "${exportfile}");
 			mailAttachment.setValue( 'majorType', Mail.Mime.toString( Mail.Mime.TYPETEXT ) );
 			mailAttachment.setValue( 'minorType', "plain" );
 			mailAttachment.save();
 			mail.attachmentsAdd( mailAttachment );
 
 			attachments[] = mailAttachment;
		
 			mail.setValue( 'attachments', attachments );
 			mail.save();
 		

 			Console.println("Finished.");
 			Console.println("Sending E-mail to export owner... using ${MailUtilities.selectMailServer()}");
 
 			if( not MailUtilities.sendMessage(connection,self.createExportMessage(mail) ) ) {
				Console.println("Unable to send email: ${connection._errstr}");
			}
		
 			Console.println("Sending internal message to the user...");

			self.sendInternalMsg(export);
		}
	}

	function saveExports(string fileName, string results){
		string exportsDirectory = (Config.CachePath - 'Cache/') + 'Exports/';
		string path = exportsDirectory + fileName;
		object file = File.open( path, FileSystem.O_RDWR );

		if ( file ) {
			
			file.seek(0,Stream.SEEK_END);
			file.write(results);
		} else {
			File.create(path, 0644) using ( f ) {
				
				f.write( results );
			};
		}
	}
	

	array seen;
	function resetUnique {
		.seen = [];
	}
	function uniqueRow(array A ) {


	
		array result = [];

		
		
		A.each() using ( row ) {
			string tag = row.join(':');
			if( not (.seen.keyExists(tag)) ) {
				.seen[tag] = true;
				result[] = row;
			}
		};

		//self.resetUnique();
		

		return result;
	}


/*************Function for match Generating CSV file*****************************/	
/*************Function for match Generating CSV file
Created by : Kreshano Dutta
************************************************/	

	function generateCSV(array dataForFile, object export, string status, string fileName)
	{
		array collumnHeader;
		string resultCSV = "",currentTimeStamp = self.getTimestamp();		
		object fileWriteObject;
		boolean flag;
		number count = 0;	

		dataForFile = self.uniqueRow(dataForFile);

		dataForFile and dataForFile[0].each() using( temp )
		{
			collumnHeader[] = Array.getName(dataForFile[0],count);
			count++;
		};

	
		dataForFile.each() using ( tempArray )
		{
			flag = false;
			collumnHeader.each() using ( key ) 
			{
				if( flag )
					resultCSV += ",";
				resultCSV += tempArray[ key ];
				flag = true;
			};
			resultCSV += "\n";
		};
		

		
		self.saveExports(fileName, resultCSV );
		return fileName;
	}


	function getTimestamp() {
	
		return Date.date(Date.GMTnow()).format("%Y%m%d-%I%M");

	}

/*************Function for match Generating XLS file
Created by : Kreshano Dutta
************************************************/	
	function generateXLS( array dataForFile, object export, string status,string fileName )
	{
		string resultXLS = "";
		object fileWriteObject;
		array collumnHeader;
		string currentTimeStamp = self.getTimestamp();
		number count = 0;		
		
			
		dataForFile and dataForFile[0].each() using( temp )
		{
			collumnHeader[] = Array.getName(dataForFile[0],count);
			count++;
		};

		if ("start" == status || "complete" == status ) { 

			resultXLS =  "<html>\n";
			resultXLS += "<head>\n";
			resultXLS += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n";
			resultXLS += "</head>\n";
			
			resultXLS += "<body>\n";
			resultXLS += "<table border=1>\n";
			resultXLS += "<tr>\n";

		
			
			
			collumnHeader.each() using ( collumn )
			{
				resultXLS += "<td>" + collumn + "</td>";
			};
	
			resultXLS += "\n";
			resultXLS += "</tr>\n";
		}
		
		dataForFile.each() using ( tempArray )
		{
			resultXLS += "<tr>\n";
			collumnHeader.each() using ( key ) 
			{
				resultXLS += "<td>" + Regexp.replaceAll("\r?\n", EscapeHTML(tempArray[key]), "<br />\r\n") + "</td>\n";
			};
			resultXLS += "</tr>\n";	
		};
		
		if ( "end" == status || "complete" == status ) {
			resultXLS += "</table>\n";
			resultXLS += "</body>\n";	
			resultXLS +=  "</html>";	
			
		}
		//fileName = export.name + currentTimeStamp + ".xls";
		self.saveExports(fileName, resultXLS );
		return fileName;

	}


/*************Function for match Generating XML file
Created by : Kreshano Dutta
************************************************/	

	function generateXML(array dataForFile, object export , string status, string fileName )
	{
		array tagName;
		string resultXML = "";
		object fileWriteObject;
 		string currentTimeStamp = self.getTimestamp();	
		number count = 0;

		
		dataForFile = self.uniqueRow(dataForFile);
		
		dataForFile and dataForFile[0].each() using( temp )
		{
			tagName[] = Array.getName(dataForFile[0],count);
			count++;
		};

		if ( "start" == status ) {
			resultXML += "<root>";
			resultXML += "\n";
		}

		dataForFile.each() using ( tempArray )
		{
			resultXML += "<data>" ;	
			resultXML += "\n";
			tagName.each() using ( key ) 
			{
				resultXML += "<" + key + ">" + tempArray[ key ] + "</" + key + ">";	
				resultXML += "\n";
			};
			resultXML +="</data>";	
			resultXML += "\n";
		};
	
		if ( "end" == status ) {
			resultXML += "</root>";
			resultXML += "\n";
		}

		self.saveExports(fileName, resultXML );
		return fileName;
	}
	
}

